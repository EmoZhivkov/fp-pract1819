# Библиотека за матрици

Да реализираме малка "библиотечка" за матрици, която евентуално да е полезна при следващото домашно. Можете да използвате наготово всички функций, които сме писали на упражнения.

`Матрица` ще наричаме списък от списъци, такъв че всеки подсписък е с еднаква дължина.

Примери за матрици:
```
'()

'((1))

'((1 0)
  (0 1))

'((1 2 3)
  (4 5 6)
  (7 8 9))
```
Примери за неща, които не са матрици:
```
'((1 2 3)
  (1))

'(()
  (1 2 3)
  (1 2))
```

### Легенда
```
A -> B
```
Означава, че изразът `A` се оценява до `B`.

### Конвенция

Където пише `xs`, `xs` това е списък.

Където пише `xss`, `xss` е матрица.

Подобно за `ys`, `yss`, `zs`, `zss`.

Тъй като разбрах, че някои хора не знаят защо правим така -
Ако имаме един елемент, той е просто `x`, ако има много елементи, имаме много
`x`-ове, демек `x`s, демек `xs`.

### Export-ване

За да направите функцийте си достъпни за "импортване" (`include`-ване) ги изброявате в `(provide x)` израз.

Пример:

Нека имаме файл `fun.rkt` със следното съдържание:

```scheme
#lang racket

(provide succ
         pred
         id
         const)

(define (succ n) (+ n 1))
(define (pred n) (- n 1))

(define (id x) x)

(define (const x) (lambda (y) x))
```

Сега, ако имаме в същата директория като `fun.rkt` файл `yoyo.rkt`, в него можем да използваме `(require "fun.rkt")`, за да имаме достъпни функцийте от `fun.rkt`.:

(Алтернативно можем да посочим и релативен или абсолютен път до `fun.rkt`)

```scheme
#lang racket

(require "fun.rkt")

(define (my-plus x y)
    (if (= 0 x)
        y
        (succ (my-plus (pred x) y))))
```

Тоест в крайна сметка идеята ни е да `provide`-нем всички функций от нашата библиотека (за да ги ползваме за следващото домашно, ако са ни нужни).


### Функцийте, които трябва да имплементирате

01. `(all? p? xs)`

    Проверява дали всички елементи на `xs` изпълняват предиката `p?`.

    Примери:
    ```scheme
    (all? even? '(2 4 6))   -> #t
    (all? even? '(1 2 4 6)) -> #f
    (all? even? '())        -> #t
    ```
02. `(any? p? xs)`

    Проверява дали има елемент на `xs`, който изпълнява предиката `p?`.

    Примери:
    ```scheme
    (any? even? '(1 2 4 6)) -> #t
    (any? odd? '(2 4 6))    -> #f
    (any? even? '())        -> #f
    ```
03. `(concat xss)`

    Взима списък от списъци и ги слепя един за друг.

    Примери:
    ```scheme
    (concat '((1 2 3) (4 5 6) (7 8 9))) -> '(1 2 3 4 5 6 7 8 9)
    (concat '())                        -> '()
    (concat '(() () () () () () ()))    -> '()
    ```
04. `(rows xss)`

    Връща редовете на `xss` като списък.

    Примери:
    ```scheme
    (rows '((1 2 3)
            (4 5 6)
            (7 8 9))) ->  '((1 2 3) (4 5 6) (7 8 9))
    ```
05. `(cols xss)`

    Връща колоните на `xss` като списък.

    Примери:
    ```scheme
    (cols '((1 2 3)
            (4 5 6)
            (7 8 9))) ->  '((1 4 7) (2 5 8) (3 6 9))
    ```
06. `(matrix-ref xss i j)`

    Индексира матрица, както индексираме и списък. Само дето с два индекса, очевидно.
    Тоест връща `j`-тия елемент от `i`-тия ред на `xss`. Индексите започват от `0`.

    Примери:
    ```scheme
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 1 1) -> 5
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 1 0) -> 4
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 0 2) -> 3
    ```
07. `(place xss i j x)`

    Връща матрица, която е същата като `xss`, само че на индекс `i` `j` седи елементът `x`.

    Примери:
    ```scheme
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 1 1 42)   -> '((1 2 3) (4 42 6) (7 8 9))
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 1 0 69)   -> '((1 2 3) (69 5 6) (7 8 9))
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 0 2 1337) -> '((1 2 1337) (4 5 6) (7 8 9))
    ```
08. `(diag xss)`

    Връща главния диагонал на `xss`.

    Примери:
    ```scheme
    (diag '((1 2 3)
            (4 5 6)
            (7 8 9))) -> '(1 5 9)
    (diag '((1))) -> '(1)
    (diag '((1 0)
            (0 1))) -> '(1 1)
    ```
09. `(reverse-cols xss)`

    Обръща колоните на `xss`.

    Примери:
    ```scheme
    (reverse-cols '((1 0)
                    (0 1)))   -> '((0 1) (1 0))
    (reverse-cols '((1 2 3)
                    (4 5 6)
                    (7 8 9))) -> '((3 6 9) (2 5 8) (1 4 7))
    ```
10. `(diags xss)`

    Връща и двата диагонала на `xss` (hint: ползвайте `reverse-cols`).

    Примери:
    ```scheme
    (diags '((1 0)
             (0 1)))   -> '((1 1) (0 0))
    (diags '((1 2 3)
             (4 5 6)
             (7 8 9))) -> '((1 5 9) (3 5 7))
    ```
11. `(map-matrix f xss)`

    Прилага `f` на всеки елемент на `xss` и връща преубрзуваната матрица. Като за списъци.

    Примери:
    ```scheme
    (define (+1 x) (+ 1 x))
    (define (id x) x)
    (define (const x) (lambda (y) x))

    (map-matrix id         '((1337)))  -> '((1337))
    (map-matrix +1         '((1 0)
                             (0 1)))   -> '((1 1) (0 0))
    (map-matrix (const 69) '((1 2 3)
                             (4 5 6)
                             (7 8 9))) -> '((69 69 69)
                                            (69 69 69)
                                            (69 69 69))
    ```
12. `(filter-matrix p? xss)`

    Оставя само елементите на `xss`, които изпълняват предиката `p?`.
    Забележете, че резултатът на тази функция не е матрица в общия случай.

    Примери:
    ```scheme
    (filter-matrix odd?  '((1 2 3)
                           (4 5 6)
                           (7 8 9))) -> '((1 3) (5) (7 9))
    (filter-matrix zero? '((1 0)
                           (0 1)))   -> '((0) (0))
    (filter-matrix zero? '((1 2 3)
                           (4 5 6)
                           (7 8 9))) -> '(() () ())
    ```
13. `(zip-with f xs ys)`

    Прилага покомпонентно `f` върху елементите на `xs` и `ys` и връща списък с резултатите.
    Ако някой от списъците е по-къс отрязва и по-дългия до дължината на по-късия.

    Примери:
    ```scheme
    (zip-with cons '(1 2 3) '(4 5 6))              -> '((1 . 4) (2 . 5) (3 . 6))
    (zip-with cons '(1) '(4 5 6))                  -> '((1 . 4))
    (zip-with + '(60 1300 40) '(9 37 2))           -> '(69 1337 42)
    (zip-with string-append '("y" "y") '("o" "o")) -> '("yo" "yo")
    ```
14. `(zip-matrix xss yss)`

    Прави нова матрица, която съдържа като елементи наредени двойки, покомпонентно елементите на `xss` и на `yss`.

    Примери:
    ```scheme
    (zip-matrix '((1 2))
                '((3 4))) -> '(((1 . 3) (2 . 4)))
    (zip-matrix '((1 0)
                  (0 1))
                '((6 9)
                  (9 6))) -> '(((1 . 6) (0 . 9))
                               ((0 . 9) (1 . 6)))
    ```
