#### Моля прочетете Homework guidelines в README.md

# Библиотека за матрици

Да реализираме малка "библиотечка" за матрици, която евентуално да е полезна при следващото домашно. Можете да използвате наготово всички функции, които сме писали на упражнения.

`Матрица` ще наричаме списък от списъци, такъв че всеки негов елемент е с еднаква дължина.
`Елементи на матрица`, ще наричаме елементите на всичките ѝ елементи (демек елементите на вложените списъци).

Примери за матрици:
```
'()

'((1))

'((1 0)
  (0 1))

'((1 2 3)
  (4 5 6)
  (7 8 9))
```
Примери за неща, които не са матрици:
```
'((1 2 3)
  (1))

'(()
  (1 2 3)
  (1 2))
```

### Легенда
```
A -> B
```
Означава, че изразът `A` се оценява до `B`.

### Конвенция

Където пише `xs`, `xs` това е списък.

Където пише `xss`, `xss` е матрица.

Подобно за `ys`, `yss`, `zs`, `zss`.

Тъй като разбрах, че някои хора не знаят защо правим така -
Ако имаме един елемент, той е просто `x`, ако има много елементи, имаме много
`x`-ове, демек `x`s, демек `xs`.

### Export-ване

За да направите функциите си достъпни за "импортване" (`include`-ване) ги изброявате в `(provide x)` израз.

Пример:

Нека имаме файл `fun.rkt` със следното съдържание:

```scheme
#lang racket

(provide succ
         pred
         id
         const)

(define (succ n) (+ n 1))
(define (pred n) (- n 1))

(define (id x) x)

(define (const x) (lambda (y) x))
```

Сега, ако имаме в същата директория като `fun.rkt` файл `yoyo.rkt`, в него можем да използваме `(require "fun.rkt")`, за да имаме достъпни функциите от `fun.rkt`.:

(Алтернативно можем да посочим и релативен или абсолютен път до `fun.rkt`)

```scheme
#lang racket

(require "fun.rkt")

(define (my-plus x y)
    (if (= 0 x)
        y
        (succ (my-plus (pred x) y))))
```

Тоест в крайна сметка идеята ни е да `provide`-нем всички функции от нашата библиотека (за да ги ползваме за следващото домашно, ако са ни нужни).


### Функциите, които трябва да имплементирате

01. `(all? p? xs)`

    Проверява дали всички елементи на `xs` изпълняват предиката `p?`.

    Примери:
    ```scheme
    (all? even? '(2 4 6))   -> #t
    (all? even? '(1 2 4 6)) -> #f
    (all? even? '())        -> #t
    ```
    **Използвайте** `map` и/или `fold{l,r}` за реализацията на функцията.
02. `(any? p? xs)`

    Проверява дали има елемент на `xs`, който изпълнява предиката `p?`.

    Примери:
    ```scheme
    (any? even? '(1 2 4 6)) -> #t
    (any? odd? '(2 4 6))    -> #f
    (any? even? '())        -> #f
    ```
    **Използвайте** `map` и `all?` (или `map` и/или `fold{l,r}`, отново) за реализацията на функцията.
03. `(concat xss)`

    Взима списък от списъци и ги слепя един за друг.

    Примери:
    ```scheme
    (concat '((1 2 3) (4 5 6) (7 8 9))) -> '(1 2 3 4 5 6 7 8 9)
    (concat '())                        -> '()
    (concat '(() () () () () () ()))    -> '()
    ```
    **Използвайте** `fold{l,r}` за реализцията на функцията.
04. `(rows xss)`

    Връща редовете на матрица `xss` като списък.

    Примери:
    ```scheme
    (rows '((1 2 3)
            (4 5 6)
            (7 8 9))) ->  '((1 2 3) (4 5 6) (7 8 9))
    ```
05. `(cols xss)`

    Връща колоните на матрица `xss` като списък.

    Примери:
    ```scheme
    (cols '((1 2 3)
            (4 5 6)
            (7 8 9))) ->  '((1 4 7) (2 5 8) (3 6 9))
    ```
    **Hint**: `car` и `cdr` взимат главата/опашката на един списък. Как можем да вземем главата/опашката на **всеки** елемент на даден списък?
06. `(matrix-ref xss i j)`

    Индексира матрица `xss`, както индексираме и списък. Само дето с два индекса, очевидно.
    Тоест връща `j`-тия елемент от `i`-тия ред на `xss`. Индексите започват от `0`.

    Примери:
    ```scheme
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 1 1) -> 5
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 1 0) -> 4
    (matrix-ref '((1 2 3)
                  (4 5 6)
                  (7 8 9)) 0 2) -> 3
    ```
    **Hint**: Имате вече функция за индексирне на списъци.
07. `(set xs i x)`

    Връща списък, който е същият като `xs`, само че на индекс `i` седи елементът `x`.

    Примери:
    ```scheme
    (set '(1 2 3) 2 1337)   -> '(1 2 1337)
    (set '(1 2 3 4 5) 0 42) -> '(42 2 3 4 5)
    ```
08. `(place xss i j x)`

    Връща матрица, която е същата като матрицата `xss`, само че на индекс `i` `j` седи елементът `x`.

    Примери:
    ```scheme
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 1 1 42)   -> '((1 2 3)
                                     (4 42 6)
                                     (7 8 9))
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 1 0 69)   -> '((1 2 3)
                                     (69 5 6)
                                     (7 8 9))
    (place '((1 2 3)
             (4 5 6)
             (7 8 9)) 0 2 1337) -> '((1 2 1337)
                                     (4 5 6)
                                     (7 8 9))
    ```
    **Hint**: Вече имате функция която сменя елемент на списък.
09. `(diag xss)`

    Връща главния диагонал на матрица `xss`.

    Примери:
    ```scheme
    (diag '((1 2 3)
            (4 5 6)
            (7 8 9))) -> '(1 5 9)
    (diag '((1))) -> '(1)
    (diag '((1 0)
            (0 1))) -> '(1 1)
    ```

10. `(diags xss)`

    Връща и двата диагонала на `xss`.

    Примери:
    ```scheme
    (diags '((1 0)
             (0 1)))   -> '((1 1) (0 0))
    (diags '((1 2 3)
             (4 5 6)
             (7 8 9))) -> '((1 5 9) (3 5 7))
    ```
    **Hint**: Можем да "flip-нем" матрицата или вертикално, или хоризонтално, и след това просто да викнем `diag` на нея.
11. `(map-matrix f xss)`

    Прилага `f` на всеки елемент на матрицата `xss` и връща преобразуваната матрица. Като за списъци.

    Примери:
    ```scheme
    (define (1+ x) (+ 1 x))
    (define (id x) x)
    (define (const x) (lambda (y) x))

    (map-matrix id         '((1337)))  -> '((1337))
    (map-matrix 1+         '((1 0)
                             (0 1)))   -> '((2 1)
                                            (1 2))
    (map-matrix (const 69) '((1 2 3)
                             (4 5 6)
                             (7 8 9))) -> '((69 69 69)
                                            (69 69 69)
                                            (69 69 69))
    ```
    **Използвайте** `map` за реализацията на `map-matrix`.
12. `(filter-matrix p? xss)`

    Оставя само елементите на матрицата `xss`, които изпълняват предиката `p?`.
    Забележете, че резултатът на тази функция не е матрица в общия случай.

    Примери:
    ```scheme
    (filter-matrix odd?  '((1 2 3)
                           (4 5 6)
                           (7 8 9))) -> '((1 3) (5) (7 9))
    (filter-matrix zero? '((1 0)
                           (0 1)))   -> '((0) (0))
    (filter-matrix zero? '((1 2 3)
                           (4 5 6)
                           (7 8 9))) -> '(() () ())
    ```
    **Използвайте** `map` и `filter` за реализацията на `filter-matrix`.
13. `(zip-with f xs ys)`

    Прилага покомпонентно `f` върху елементите на списък `xs` и списък `ys` и връща списък с резултатите.
    Ако някой от списъците е по-къс отрязва и по-дългия до дължината на по-късия.

    Примери:
    ```scheme
    (zip-with cons '(1 2 3) '(4 5 6))              -> '((1 . 4) (2 . 5) (3 . 6))
    (zip-with cons '(1) '(4 5 6))                  -> '((1 . 4))
    (zip-with + '(60 1300 40) '(9 37 2))           -> '(69 1337 42)
    (zip-with string-append '("y" "y") '("o" "o")) -> '("yo" "yo")
    ```
14. `(zip-matrix xss yss)`

    Прави нова матрица, която съдържа като елементи наредени двойки, покомпонентно елементите на матрица `xss` и на матрица `yss`.

    Примери:
    ```scheme
    (zip-matrix '((1 2))
                '((3 4))) -> '(((1 . 3) (2 . 4)))
    (zip-matrix '((1 0)
                  (0 1))
                '((6 9)
                  (9 6))) -> '(((1 . 6) (0 . 9))
                               ((0 . 9) (1 . 6)))
    ```
    **Използвайте** `zip-with` (и `zip`) за реализацията на `zip-matrix`.
